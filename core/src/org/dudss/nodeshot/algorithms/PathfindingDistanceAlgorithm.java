package org.dudss.nodeshot.algorithms;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.dudss.nodeshot.Base;
import org.dudss.nodeshot.entities.connectors.Connector;
import org.dudss.nodeshot.entities.nodes.Node;
import org.dudss.nodeshot.screens.GameScreen;

public class PathfindingDistanceAlgorithm {
	
	int steps = -1;
	int step;
	
	Node start;
	Node target;
	
	ArrayList<Node> exploredZoneNodes = new ArrayList<Node>();
	ArrayList<Node> medianZoneNodes = new ArrayList<Node>();
	ArrayList<Node> activeZoneNodes = new ArrayList<Node>();
	
	List<List<Node>> possiblePathways = new ArrayList<List<Node>>();
	List<Double> distances = new ArrayList<Double>();
	
	Map<Integer, ArrayList<Node[]>> nodeDuosMap; 
	
	Boolean failed = false;
	
	public PathfindingDistanceAlgorithm(Node start, Node target) {
		this.start = target;	 
		this.target = start;
		exploredZoneNodes.add(this.start);
		nodeDuosMap = new HashMap<Integer, ArrayList<Node[]>>(); 
		
		//Does all the calculations and makes Path and Steps accessible on init
		if (start != null && target != null) {
			this.process();
		} else {
			failed = true;
			steps = -1;
		}
	}
	
	void process() {
		
		//Steps calculation, nodeDuosMap filling
		if (start == target) {
			steps = 0;
			return;
		}
		
		//Check if nodes are in the same web
		GraphComponentsAlgorithm gCA = new GraphComponentsAlgorithm();
		List<ArrayList<Node>> allWebNodes = gCA.getWebNodesList();
		
		Boolean nodesInTheSameWeb = false;
		for (ArrayList<Node> web : allWebNodes) {
			if (web.contains(start) && web.contains(target)) {
				nodesInTheSameWeb = true;
				break;
			}
		}
		
		if(nodesInTheSameWeb == false) {
			//System.out.println("Start/Target aren't in the same web!");
			steps = -1;
			failed = true;
			return;
		}
		
		step++;		
		nextZone(true);
		
		//nodeDuosMap debug
		/*
		for (int i = 1; i < nodeDuosMap.size(); i++) {
			ArrayList<Node[]> nA = new ArrayList<Node[]>();
			nA = nodeDuosMap.get(i); 
			for (Node[] nE : nA) {
				System.out.println(nE[0].getIndex());
				System.out.println(nE[1].getIndex());
				System.out.println("++");
			}
			System.out.println("---------");
		}
		*/
		
		//Path calculation (Uses nodeDuosMap generated by previous code)
		newFork(start.getIndex(), nodeDuosMap.size() - 1, new ArrayList<Node>());
		
		//Pathways debug
		/*int a = 0;
		System.out.println("\n");
		for (List<Node> aN : possiblePathways) {
			a++;
			System.out.println("Pathway " + a + " distance: " + distances.get(a - 1));
			for(Node n : aN) {
				System.out.print(n.getIndex() + " - ");
			}
			System.out.println("\n");
		}
		*/
	}
	
	void nextZone(Boolean first) {
		ArrayList<Node[]> listOfStepNodeDuos = new ArrayList<Node[]>();
		
		if (first == true) {
			medianZoneNodes.add(start);
		}
		
		for (Node n : medianZoneNodes) {
			ArrayList<Node> temp = new ArrayList<Node>(n.getAllConnectedNodes());
			for(Node node : temp) {
				if (!medianZoneNodes.contains(node) && !exploredZoneNodes.contains(node)) {
					Node[] duoArray = new Node[]{n, node};
					
					Boolean isDuplicate = false;	
					for (Node[] array : listOfStepNodeDuos) {
						if (Arrays.equals(array, duoArray)) {
							isDuplicate = true;
						}
					}
					if (!isDuplicate) {
						listOfStepNodeDuos.add(duoArray);
					}
					
					activeZoneNodes.add(node);
				}
			}
		}
		
		nodeDuosMap.put(step, listOfStepNodeDuos);

		if(activeZoneNodes.size() == 0) {
			return;
		}
		
		List<Node> neighbourNodes = new ArrayList<Node>();
		for (Node n : activeZoneNodes) {
			if (n == target) {
				neighbourNodes.add(n);
			}
		}
		
		activeZoneNodes.removeAll(neighbourNodes);
		
		step++;
		exploredZoneNodes.addAll(medianZoneNodes);
		medianZoneNodes.clear();
		medianZoneNodes.addAll(activeZoneNodes);
		activeZoneNodes.clear();
		
		nextZone(false);
	}
	
	void newFork(int previousIndex, int step, ArrayList<Node> currentChain) {
		int tempStep = new Integer(step);
		int tempPreviousIndex = new Integer(previousIndex);
		
		//Current path chain
		ArrayList<Node> tempCurrentChain = new ArrayList<Node>(currentChain);	
		
		//List of all the possible paths, arrays of 2 in a list. (Node - (Connector) - Node)
		ArrayList<Node[]> currentStepDuos = null;
		
		if (!(tempStep <= 0)) {
			//Get the Node duos for this particular step (steps from the target)
			currentStepDuos = new ArrayList<Node[]>(nodeDuosMap.get(nodeDuosMap.size() - tempStep));
		} else {
			return;
		}
		
		for (Node[] nA : currentStepDuos) {
			//For every duo, if the first array element equals the previous step last element -> those are connected, add to the chain and proceed
			if (tempPreviousIndex == nA[0].getIndex() || tempPreviousIndex == -1) {
				tempCurrentChain.add(nA[0]);
				tempCurrentChain.add(nA[1]);
				int newStep = step - 1;
				
				if (nA[1] != target) {
					newFork(nA[1].getIndex(), new Integer(newStep), tempCurrentChain);
				} else {
					//Path target found! Add current chain to possible pathways and calculate distance					
					//Removing duplicates (4-3 3-2 2-1 --> 4 - 3 - 2 - 1)
					ArrayList<Node> newPathway = new ArrayList<Node>();
					double totalDistance = 0;
					Node previous = null;
					for (Node n : tempCurrentChain) {
						//Distance calculation
						if (previous != null && previous != n) {
							Connector c = GameScreen.connectorHandler.getConnectorInbetween(previous, n, n.getConnectors());
							totalDistance += c.getLenght();
						}
						if (previous == null || previous != n) {
							newPathway.add(n);
						}
						previous = n;
					}

					possiblePathways.add(newPathway);
					distances.add(totalDistance);
					
					return;
				}
				//Idk what this does, removing it breaks things
				tempCurrentChain.remove(tempCurrentChain.size() - 1);
			} 
		}
	}
	
	//Getter
	public int getSteps() {
		return steps;
	}
	
	//Getter
	public List<List<Node>> getPathway() {
		return possiblePathways;
	}
	
	public List<Node> getShortestPath() {
		List<Node> shortestPath = null;
		double dist = Double.MAX_VALUE;
		for (List<Node> path : possiblePathways) {
			double pathDist = distances.get(possiblePathways.indexOf(path));
			if (pathDist < dist) {
				shortestPath = path;
				dist = pathDist;
			}
		}
		List<Node> shallowCopy = shortestPath.subList(0, shortestPath.size());
		Collections.reverse(shallowCopy);	
		return shallowCopy;
	}
	
	public Double getShortestDistance() {
		List<Node> shortestPath = null;
		double dist = Double.MAX_VALUE;
		for (List<Node> path : possiblePathways) {
			double pathDist = distances.get(possiblePathways.indexOf(path));
			if (pathDist < dist) {
				shortestPath = path;
				dist = pathDist;
			}
		}
		return dist;
	}
	
	public List<Node> getRandomPath() {
		List<Node> path;
		//If there is only one possible pathway, use that one
		if (possiblePathways.size() == 1) {
			path = possiblePathways.get(0);
		} else {
			//Gets random path //TODO: additional distance calculations
			path = possiblePathways.get(Base.getRandomIntNumberInRange(0, possiblePathways.size()-1));
		}
		
		return path;
	}
	
	public boolean failed() {
		return failed;
	}
}